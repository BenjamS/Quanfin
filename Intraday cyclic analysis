---
title: "Trade Strategy"
author: "Ben Schiek"
date: "`r Sys.Date()`"
output: 
  pdf_document:
    number_sections: true
    latex_engine: xelatex
mainfont: Garamond
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      warning = FALSE)

library(tidyverse)
library(tidyquant)
library(WaveletComp)
library(patchwork)
library(kableExtra)
library(xtable)
#========================================================================
# Define functions
#========================================================================
fitWave <- function(ts, per_vec, n_max_periods = 5, pval_thresh = 0.01, n_lookAhead = 30){
  n_t <- length(ts)
  t <- 1:n_t
  regrsrs_sin <- paste0("sin(2 * pi / per_vec[", c(1:n_max_periods), "] * t)", collapse = " + ")
  regrsrs_cos <- paste0("cos(2 * pi / per_vec[", c(1:n_max_periods), "] * t)", collapse = " + ")
  regrsrs <- paste(regrsrs_sin, regrsrs_cos, sep = " + ")
  this_formula <- as.formula(paste("ts ~ -1 +", regrsrs)[1])
  linmod <- lm(this_formula)
  summod <- summary(linmod)
  #summod
  pvals <- as.numeric(summod$coefficients[, 4])
  ind_rm <- which(pvals > pval_thresh)
  round <- 0
  while(length(ind_rm) > 0){
    round <- round + 1
    print(paste("round ", round))
    if(round == 7){
      print("Too many rounds, aborting.")
      break
    }
    regrsrs_char <- strsplit(as.character(regrsrs), " \\+ ")[[1]]
    regrsrs_char <- regrsrs_char[-ind_rm]
    regrsrs <- paste(regrsrs_char, collapse = " + ")
    this_formula <- as.formula(paste("ts ~ -1 +", regrsrs)[1])
    linmod <- lm(this_formula)
    #---------------------
    summod <- summary(linmod)
    #print(summod)
    pvals <- as.numeric(summod$coefficients[, 4])
    ind_rm <- which(pvals > pval_thresh)
  }
  fitted_wave <- fitted(linmod)
  
  t <- (n_t + 1):(n_t + n_lookAhead)
  regrsrs_fut <- names(linmod$coefficients)
  #regrsrs_fut <- gsub("t", "t_fut", regrsrs_fut)
  list_fut <- list()
  for(i in 1:length(regrsrs_fut)){
    list_fut[[i]] <- eval(parse(text = regrsrs_fut[i]))
  }
  df_fut <- as.data.frame(do.call(cbind, list_fut))
  predict_wave <- predict(linmod, df_fut, interval = "prediction")  
  print(summod)

  list_out <- list(fitted_wave, predict_wave, summod)
  return(list_out)
}
#========================================================================
plot_validation <- function(yhat, ypredict, df_wave){
  df_plot <- df_wave
  df_plot$yhat <- c(yhat, ypredict[, 1])
  df_plot$set <- NA
  df_plot$set[ind_fit] <- "fit"
  df_plot$set[ind_test] <- "test"
  df_plot$yhat_p <- df_plot$p + df_plot$yhat
  df_plot <- df_plot %>% gather(Type, Value, p:yhat_p)
  df_plot$Value <- as.numeric(df_plot$Value)
  #unique(df_plot$Type)
  df_plot_ts <- subset(df_plot, Type %in% c("p", "ema", "yhat_p"))
  df_plot_ts_dtFit <- subset(df_plot, Type %in% c("dt", "yhat"))

  n_types_fit <- length(unique(df_plot_ts_dtFit$Type))
  n_types_ts <- length(unique(df_plot_ts$Type))
  distinct_colors <- randomcoloR::distinctColorPalette(k = n_types_fit + n_types_ts)
  colors_dtFit <- distinct_colors[1:n_types_fit]
  colors_ts <- distinct_colors[(n_types_fit + 1):(n_types_fit + n_types_ts)]
  
  df_plot_dt <- subset(df_plot_ts_dtFit, Type == "dt")
  df_plot_dtFit <- subset(df_plot_ts_dtFit, Type == "yhat")
  
  gg <- ggplot()
  gg <- gg + geom_line(data = df_plot_dtFit, aes(x = date, y = Value, color = Type), lwd = 1.1)#, color = colors_dtFit[2], lwd = 1.1)
  gg <- gg + geom_line(data = df_plot_dt, aes(x = date, y = Value, color = Type))#, color = colors_dtFit[1])
  gg <- gg + scale_color_manual(values = colors_dtFit)
  gg <- gg + geom_vline(xintercept = df_plot$date[ind_test[1]], lwd = 1, color = "violet")
  gg <- gg + geom_hline(yintercept = 0, color = "violet", lwd = 1)
  gg <- gg + theme_bw()
  gg <- gg + theme(axis.title = element_blank(),
                   legend.title = element_blank(),
                   #legend.position = "top",
                   axis.text.x = element_blank(),
                   axis.ticks.x = element_blank())
  #gg <- gg + scale_color_brewer(palette = "Dark2")
  gg_dtFit <- gg
  
  df_plot_yhat_p <- subset(df_plot_ts, Type == "yhat_p")
  df_plot_p_ema <- subset(df_plot_ts, Type != "yhat_p")
  gg <- ggplot()
  gg <- gg + geom_line(data = df_plot_p_ema, aes(x = date, y = Value, group = Type, color = Type))
  gg <- gg + geom_line(data = df_plot_yhat_p, aes(x = date, y = Value, color = Type), lwd = 1.1)
  gg <- gg + scale_color_manual(values = colors_ts)
  gg <- gg + geom_vline(xintercept = df_plot$date[ind_test[1]], color = "violet", lwd = 1)
  gg <- gg + theme_bw()
  gg <- gg + theme(axis.title = element_blank(),
                   #legend.position = "bottom",
                   legend.title = element_blank())
  gg_ts <- gg
  
  gg_together <- gg_dtFit + gg_ts + plot_layout(ncol = 1, heights = c(2, 1))
  
  print(gg_together)
}
#========================================================================
plot_prediction <- function(yhat, ypredict, df_wave, time_step, n_lookAhead = 30){
  n_end <- nrow(df_wave)
  df_wave <- df_wave[, c("date", "dt")]
  df_wave$yhat <- yhat
  df_wave$set <- "fit"
  df_wave$t <- NULL
  time_step <- as.numeric(stringr::str_extract_all(time_step, "[0-9]+")[[1]])
  date_fut <- seq((df_wave$date[nrow(df_wave)] + time_step), (df_wave$date[nrow(df_wave)] + 2 * time_step * n_lookAhead), by = time_step)
  date_fut <- date_fut[!weekdays(date_fut) %in% c('Saturday','Sunday')]
  #length(date_fut)
  date_fut <- date_fut[1:n_lookAhead]
  df_add <- data.frame(date = date_fut, dt = NA, yhat = ypredict[, 1], set = "predict")
  df_wave <- rbind(df_wave, df_add)
  df_plot <- df_wave
  df_plot <- df_plot %>% gather(Type, Value, dt:yhat)
  n_types_fit <- length(unique(df_plot$Type))
  distinct_colors <- randomcoloR::distinctColorPalette(k = n_types_fit)
  colors_dtFit <- distinct_colors
  
  df_plot_dt <- subset(df_plot, Type == "dt")
  df_plot_dtFit <- subset(df_plot, Type == "yhat")
  gg <- ggplot()
  gg <- gg + geom_line(data = df_plot_dtFit, aes(x = date, y = Value, color = Type), lwd = 1.1)#, color = colors_dtFit[2], lwd = 1.1)
  gg <- gg + geom_line(data = df_plot_dt, aes(x = date, y = Value, color = Type))#, color = colors_dtFit[1])
  gg <- gg + scale_color_manual(values = colors_dtFit)
  gg <- gg + geom_vline(xintercept = df_plot$date[n_end], lwd = 1, color = "violet")
  gg <- gg + geom_hline(yintercept = 0, color = "violet", lwd = 1)
  gg <- gg + theme_bw()
  gg <- gg + theme(axis.title = element_blank(),
                   legend.title = element_blank(),
                   #legend.position = "top",
                   axis.ticks.x = element_blank())
  #gg <- gg + scale_color_brewer(palette = "Dark2")
  print(gg)
}
#========================================================================
get_cycles <- function(waveAnalysis){
  df_periodogram <- data.frame(period = waveAnalysis$Period, power = waveAnalysis$Power.avg)
  ind_critPoints <- findPeaks(df_periodogram$power)
  critPers <- df_periodogram$period[ind_critPoints]
  critPers
  #-------------------
  gg <- ggplot(df_periodogram, aes(x = period, y = power))
  gg <- gg + geom_line()
  gg <- gg + geom_vline(xintercept = critPers, color = "cyan", size = 1.5)
  gg <- gg + theme_bw()
  print(gg)
  #-------------------
  # Get periods, ordered from most power to least
  critPwrs <- df_periodogram$power[ind_critPoints]
  ind_order <- order(critPwrs, decreasing = T)
  per_vec <- critPers[ind_order]
  pwr_vec <- critPwrs[ind_order]
  df_mainCycles <- data.frame(Num = c(1:length(per_vec)), Period = per_vec, Power = pwr_vec)
  #-------------------
  return(df_mainCycles)
  
}
#========================================================================
#========================================================================
# End function definition
#========================================================================
#========================================================================

```


```{r, fig.show = 'hold', fig.align='center', fig.cap="\\label{fig:basic}Basic plot of (bottom) time series with an EMA, and (top) the ts detrended.", fig.height=4, fig.width=7, echo=FALSE}
#======================================================
# Set parameters
symb_currency_from <- "EUR"
symb_currency_to <- "USD"
#this_symb <- "SPY"
time_step <- "5min"
per_ema_short <- 21
per_ema_for_detrend <- 34
per_ema_long <- 55
n_lookAhead <- 50
backtest_fraction <- 1 / 4
#======================================================
#fromdate <- Sys.Date() - starting_how_many_days_ago
# tbl_ohlcv <- tq_get(this_guy, get = "stock.prices", from = fromdate)
#tbl_ohlcv <- tq_get(currency_symbs, get = "stock.prices", from = fromdate)
# df_ohlcv <- as.data.frame(tbl_ohlcv)
av_api_key("HQBAWJK4Y3YW81VG")
if(!is.null(symb_currency_from)){
  tbl_ohlcv <- tq_get("", get = "alphavantager", av_fun = "FX_INTRADAY", interval = time_step, from_symbol = symb_currency_from, to_symbol = symb_currency_to, outputsize = "full")
}else{
tbl_ohlcv <- this_symbol %>%
  tq_get(get = "alphavantager", av_fun = "TIME_SERIES_INTRADAY", interval = "5min", outputsize = "full")  
}
df_ohlcv <- as.data.frame(tbl_ohlcv)
#nrow(df_ohlcv)
df_ohlcv$p <- rowSums(df_ohlcv[, c(3:5)]) / 3
colnames(df_ohlcv)[1] <- "date"
#--
df <- df_ohlcv[, c("date", "p")]
df <- as.data.frame(df)
#df <- df %>% mutate(date = as.POSIXct(date, format = "%Y-%m-%d %H:%M:%S"))
o <- apply(df, 2, function(x) length(which(is.na(x))))
#table(o)
#df[, -1] <- na.spline(df[, -1])
#--------------------------------------------------------------
df$ema <- EMA(df$p, per_ema_for_detrend)
df$dt <- df$p - df$ema
#--------------------------------------------------------------
# convert to character column and set up handy columns for making breaks
df <- df %>%
      mutate(date_chr = as.character(df$date),
             day = lubridate::day(date),
             hour = lubridate::hour(date),
             minute = lubridate::minute(date),
             new_day = if_else(day != lag(day) | is.na(lag(day)), 1, 0))
# breaks equally spaced
my_breaks <- df$date_chr[seq.int(1, length(df$date_chr), by = 30)]
#my_breaks <- df[df$minute == 0,]$date_chr
#my_breaks <- df[df$new_day == 1,]$date_chr
#------------------------------------------------------------
# Basic overview plot
gg <- ggplot(df, aes(x = date_chr, y = dt, group = 1))
gg <- gg + geom_line()
gg <- gg + scale_x_discrete(breaks = my_breaks)
gg <- gg + theme(axis.text.x = element_text(angle = 60, hjust = 1),
                 axis.title.x = element_blank())
gg_dt <- gg
#------------------------------------------------------------
df_plot <- df[, c("date_chr", "p", "ema")]
colnames(df_plot)[3] <- paste("ema", per_ema_for_detrend)
df_plot$ema_short <- EMA(df$p, per_ema_short)
df_plot$ema_long <- EMA(df$p, per_ema_long)
colnames(df_plot)[4] <- paste("ema", per_ema_short)
colnames(df_plot)[5] <- paste("ema", per_ema_long)

gathercols <- colnames(df_plot)[2:ncol(df_plot)]
df_plot <- df_plot %>% gather_("Type", "p", gathercols)

gg <- ggplot(df_plot, aes(x = date_chr, y = p, group = Type, color = Type))
gg <- gg + geom_line()
gg <- gg + scale_x_discrete(breaks = my_breaks)
gg <- gg + theme(legend.title = element_blank(),
                 axis.title.x = element_blank(),
                 axis.text.x = element_blank())
gg_raw <- gg
#------------------------------------------------------------
gg_raw / gg_dt / plot_layout(ncol = 1)
#------------------------------------------------------------

```

```{r, echo=FALSE, include=FALSE}
#------------------------------------------------------------
  df_wave <- df[-c(1:(per_ema_for_detrend + 1)), c("date", "p", "ema", "dt")]
#------------------------------------------------------------
    waveAnalysis <- analyze.wavelet(df_wave, "dt",
                          loess.span = 0,
                          dt = 1,
                          lowerPeriod = 2^1,
                          upperPeriod = 2^9,
                          make.pval = TRUE, n.sim = 10,
                          verbose = F)
#------------------------------------------------------------
```

```{r, fig.show = 'hold', fig.align='center', fig.cap="\\label{fig:periods}Extraction of the ts' main cycle period lengths using the WaveletComp package.", fig.width=6, fig.height=3, echo=FALSE}
#------------------------------------------------------------
# Plot beautiful waveComp analysis
  wtImage <- wt.image(waveAnalysis, color.key = "quantile", n.levels = 250,
           legend.params = list(lab = "wavelet power levels", mar = 4.7))
  # my.rec <- reconstruct(my.w)
  # x.rec <- my.rec$series$x.r  # x: name of original series
#------------------------------------------------------------
# Get periods and plot periodogram
        df_mainCycles <- get_cycles(waveAnalysis)
per_vec <- df_mainCycles$Period
kable(round(df_mainCycles, 2)) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

#------------------------------------------------------------
```

```{r, echo=FALSE, include=FALSE}
#------------------------------------------------------------
# Get validate (backtest) info
n_test = round(backtest_fraction * nrow(df_wave))
ind_fit <- 1:(nrow(df_wave) - n_test)
ind_test <- setdiff(1:nrow(df_wave), ind_fit)
ts <- df_wave$dt[ind_fit]
out_fitWave <- fitWave(ts, per_vec, n_max_periods = 5, pval_thresh = 0.01, n_test)
yhat_validate <- out_fitWave[[1]]
ypredict_validate <- out_fitWave[[2]]
#------------------------------------------------------------
# Get predict info
ts <- df_wave$dt
out_fitWave <- fitWave(ts, per_vec, n_max_periods = 5, pval_thresh = 0.01, n_lookAhead)
yhat_pred <- out_fitWave[[1]]
ypredict_pred <- out_fitWave[[2]]
summod <- out_fitWave[[3]]
    
```
  
```{r, echo=FALSE}  

kable(round(xtable(summod), 4)) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))


## Backtest

plot_validation(yhat_validate, ypredict_validate, df_wave)

## Prediction
plot_prediction(yhat_pred, ypredict_pred, df_wave, time_step, n_lookAhead)
#--------------------------------------------------------------



```


# Introduction

Figure \ref{fig:basic} is a basic plot of the `r this_guy` time series, from `r toString(fromdate)` to `r Sys.Date()`. The bottom panel is the time series together with a `r toString(per_ema)` step exponential moving average. The time steps are `r t_units`.

\pagebreak

# Extraction of periodicity

In Figure \ref{fig:periods}, the ts' main cycle lengths (periods) are extracted using continuous wavelet based analysis (WaveletComp package). The lovely WaveletComp graphical output is included in Figure \ref{fig:waveComp}.

```{r, echo=FALSE, include=FALSE}
  # Detect periodicity
  df_wave <- df[ -c(1:(per_ema + 1)),]

at <- seq(1, nrow(my.data.a), by = 12*24) # every active day at 00:00:00
labels <- strftime(as.POSIXct(my.data.a$date[at],
format="%F %T", tz = "GMT"), format ="%b %d")

  #df_wave$dt <- scale(df_wave$dt)
  waveAnalysis <- analyze.wavelet(df_wave, "dt",
                          loess.span = 0,
                          dt = 1 / , dj = 1/250,
                          lowerPeriod = 2^3,
                          upperPeriod = 2^9,
                          make.pval = TRUE, n.sim = 10,
                          verbose = F)

```


```{r, fig.show = 'hold', fig.align='center', fig.cap="\\label{fig:periods}Extraction of the ts' main cycle period lengths using the WaveletComp package.", fig.width=6, fig.height=3, echo=FALSE}
# Get/see main periods
#list(df_wave, per_vec, df_periodogram, gg_periodogram, wtImage)
df_mainCycles <- get_cycles(waveAnalysis)
per_vec <- df_mainCycles$Period

kable(round(df_mainCycles, 2)) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))


```

```{r, fig.show = 'hold', fig.align='center', fig.cap="\\label{fig:waveComp}WaveletComp package graphic output.", fig.width=6, fig.height=3, echo=FALSE}

  wtImage <- wt.image(waveAnalysis, color.key = "quantile", n.levels = 250,
           legend.params = list(lab = "wavelet power levels", mar = 4.7))
  # my.rec <- reconstruct(my.w)
  # x.rec <- my.rec$series$x.r  # x: name of original series

```


```{r, echo=FALSE, include=FALSE}
# Validate
n_test = round(1 / 4 * nrow(df_wave))
ind_fit <- 1:(nrow(df_wave) - n_test)
ind_test <- setdiff(1:nrow(df_wave), ind_fit)
ts <- df_wave$dt[ind_fit]
out_fitWave <- fitWave(ts, per_vec, n_max_periods = 5, pval_thresh = 0.01, n_test)
yhat_validate <- out_fitWave[[1]]
ypredict_validate <- out_fitWave[[2]]

# Predict

ts <- df_wave$dt
out_fitWave <- fitWave(ts, per_vec, n_max_periods = 5, pval_thresh = 0.01, n_lookAhead)
yhat_pred <- out_fitWave[[1]]
ypredict_pred <- out_fitWave[[2]]
summod <- out_fitWave[[3]]


```

\pagebreak

# Cyclic model

A cyclic model made up of sine and cosine waves is constructed below from the periods extracted in the last step.

```{r, echo=FALSE}
kable(round(xtable(summod), 4)) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

\pagebreak

## Backtest

The cyclic model is backtested over a `r toString(n_test)` step period in Figure \ref{fig:validate}.


```{r, fig.show = 'hold', fig.align='center', fig.cap="\\label{fig:validate}Backtest of the cyclic model.", fig.width=6, fig.height=3, echo=FALSE}

plot_validation(yhat_validate, ypredict_validate, df_wave)

```


## Prediction

```{r, fig.show = 'hold', fig.align='center', fig.cap="\\label{fig:pred}Prediction based on the cyclic model.", fig.width=6, fig.height=3, echo=FALSE}

plot_prediction(yhat_pred, ypredict_pred, df_wave)

```

In Figure \ref{fig:pred}, a prediction of where the ts is headed `r toString(n_lookAhead)` `r t_units` into the future is made using the model.
